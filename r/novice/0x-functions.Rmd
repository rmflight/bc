Assumes that data types, variables, etc have already been introduced. 3 minutes is not enough time to introduce scope, pass by copy, etc, that would be more material later.

# Personal Functions

We've already introduced the idea of putting a series of commands together. Wouldn't it be great to group a series of data transformations together into functions that we could re-use later, rather than retyping or copying and pasting repeatedly?

We've already been using `R`'s built in functions in our analyses, functions such as `min`, `max`, `sd`, `plot`. Similar to other languages, `R` also makes it fairly easy to write our own functions.

## Basic Function

`R` has a function called `function` to make **new** functions. Just as we previously assigned `values` to `variables` (i.e. `myVar <- 1`), we do a similar process for `functions`:

```{r}
myFunction <- function(){
  x <- 2
  return(x)
}
```

Notice all we have done is write our usual variable assignment in the function body. Then, when we call the function, the value of the variable (`x` in this case) is returned.

```{r}
myFunction()
```

We can call this like any other function, including assigning the value that is returned to a new variable:

```{r}
myVar <- myFunction()
myVar
```

## Input Variables

Now let's make the function do something useful with input varibles. We can start by simply having a function square the value of x.

```{r}
myFunction <- function(x){
  x2 <- x ^ 2
  return(x2)
}
```

We can use this function like any other function in R.

```{r}
myFunction(x = 2)

v <- c(1, 2, 3, 4, 5)
myFunction(v)
```

How do you think you would add a second input term? In pairs or groups of 3, think about the functions you know in R and write your own custom function that takes two input values (x & y) and adds them together. Then add another calculation to multiply x and y within the same function and return them in a dataframe.

### Answers

```{r}
addTwo <- function(x, y){
  z <- x + y
  return(z)
}

addTwo(2, 3)

addMult <- function(x, y){
  add <- x + y
  mult <- x * y
  df <- data.frame(add, mult)
  return(df)
}

addMult(2, 3)

v1 <- c(1, 2, 3)
v2 <- c(1, 2, 3)
addMult(v1, v2)
```

GREG AND CLASSMATES SUGGESTED BREAKING DEFAULT VALUES INTO SEPARATE SECTION

Can you give y a default value of 0, so that if y is not entered the value of x is returned? Hint: remember you can type the name of a function to see how it works or `?functionName` to see how functions are used.


### Answers

```{r}
addTwoDefault <- function(x, y = 0){
  z <- x + y
  return(z)
}

addTwoDefault(1, 2)
addTwoDefault(1)
```

